<!DOCTYPE html>
<html lang="ru">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Лабораторная работа 5 - Алгоритмы отсечения</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    }
    
    body {
      background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
      min-height: 100vh;
      padding: 20px;
      color: #333;
    }
    
    .container {
      max-width: 1400px;
      margin: 0 auto;
      background-color: white;
      border-radius: 12px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
      overflow: hidden;
    }
    
    header {
      background: linear-gradient(90deg, #2c3e50, #4a6491);
      color: white;
      padding: 20px 30px;
    }
    
    h1 {
      font-size: 1.8rem;
      margin-bottom: 5px;
    }
    
    .subtitle {
      font-size: 1rem;
      opacity: 0.9;
    }
    
    .variant-info {
      background-color: #e3f2fd;
      padding: 10px 30px;
      border-bottom: 1px solid #bbdefb;
      font-weight: 500;
    }
    
    .content {
      display: flex;
      flex-wrap: wrap;
      padding: 0;
    }
    
    .controls {
      flex: 1;
      min-width: 300px;
      padding: 25px;
      background-color: #f9f9f9;
      border-right: 1px solid #eee;
    }
    
    .visualization {
      flex: 2;
      min-width: 500px;
      padding: 20px;
      display: flex;
      flex-direction: column;
    }
    
    .canvas-container {
      flex: 1;
      border: 1px solid #ddd;
      border-radius: 8px;
      overflow: hidden;
      background-color: #fefefe;
      position: relative;
    }
    
    canvas {
      display: block;
    }
    
    .section-title {
      font-size: 1.2rem;
      margin-bottom: 15px;
      padding-bottom: 8px;
      border-bottom: 2px solid #4a6491;
      color: #2c3e50;
    }
    
    textarea {
      width: 100%;
      height: 180px;
      padding: 12px;
      border: 1px solid #ccc;
      border-radius: 6px;
      font-family: monospace;
      font-size: 0.9rem;
      resize: vertical;
      margin-bottom: 15px;
    }
    
    .button-group {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin-bottom: 20px;
    }
    
    button {
      padding: 10px 16px;
      border: none;
      border-radius: 6px;
      background-color: #4a6491;
      color: white;
      cursor: pointer;
      font-weight: 500;
      transition: background-color 0.2s;
      flex: 1;
      min-width: 120px;
    }
    
    button:hover {
      background-color: #3a5381;
    }
    
    button.primary {
      background-color: #2c3e50;
    }
    
    button.primary:hover {
      background-color: #1a252f;
    }
    
    .algorithm-selector {
      margin-bottom: 20px;
    }
    
    .algorithm-buttons {
      display: flex;
      gap: 10px;
      margin-top: 10px;
    }
    
    .algorithm-buttons button {
      flex: 1;
    }
    
    .algorithm-buttons button.active {
      background-color: #2c3e50;
      box-shadow: inset 0 0 0 2px white;
    }
    
    .legend {
      display: flex;
      flex-wrap: wrap;
      gap: 15px;
      margin-top: 20px;
      padding: 15px;
      background-color: #f0f4f8;
      border-radius: 6px;
    }
    
    .legend-item {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .color-box {
      width: 20px;
      height: 20px;
      border-radius: 3px;
    }
    
    .status {
      margin-top: 15px;
      padding: 12px;
      border-radius: 6px;
      background-color: #e8f5e9;
      border-left: 4px solid #4caf50;
      font-size: 0.9rem;
    }
    
    .coordinates-info {
      margin-top: 15px;
      font-size: 0.9rem;
      color: #555;
    }
    
    .info-panel {
      display: flex;
      justify-content: space-between;
      margin-top: 15px;
      padding: 10px;
      background-color: #f5f5f5;
      border-radius: 6px;
      font-size: 0.9rem;
    }
    
    @media (max-width: 900px) {
      .content {
        flex-direction: column;
      }
      .controls,
      .visualization {
        min-width: 100%;
      }
    }
  </style>
</head>

<body>
  <div class="container">
    <header>
      <h1>Лабораторная работа 5: Алгоритмы отсечения отрезков и многоугольников</h1>
    </header>

    <div class="variant-info">
      Вариант 3: Алгоритм средней точки (отрезки) + Алгоритм отсечения выпуклого многоугольника
    </div>

    <div class="content">
      <div class="controls">
        <h3 class="section-title">Исходные данные</h3>
        <textarea id="inputData">7 50 50 250 200 100 20 300 120 30 150 180 80 200 30 350 180 80 180 150 250 120 100 120 250 250 50 50 250 100 100 300 250</textarea>

        <div class="button-group">
          <button id="loadExample" class="primary">Загрузить пример</button>
          <button id="clearCanvas">Очистить</button>
        </div>

        <h3 class="section-title">Алгоритмы отсечения</h3>
        <div class="algorithm-selector">
          <div class="algorithm-buttons">
            <button id="midpointBtn" class="active">Алгоритм средней точки (отрезки)</button>
            <button id="polygonBtn">Алгоритм отсечения многоугольника</button>
          </div>
        </div>

        <div class="button-group">
          <button id="drawOriginal">Нарисовать исходные данные</button>
          <button id="clipBtn" class="primary">Выполнить отсечение</button>
        </div>

        <div class="coordinates-info">
          <p><strong>Формат входных данных:</strong></p>
          <p>Первая строка: количество отрезков (n)</p>
          <p>Следующие n строк: X1 Y1 X2 Y2 (координаты отрезков)</p>
          <p>Последняя строка: Xmin Ymin Xmax Ymax (отсекающее окно)</p>
        </div>

        <div class="legend">
          <div class="legend-item">
            <div class="color-box" style="background-color: #2c3e50;"></div>
            <span>Отсекающее окно</span>
          </div>
          <div class="legend-item">
            <div class="color-box" style="background-color: #4a6491;"></div>
            <span>Исходные отрезки/многоугольник</span>
          </div>
          <div class="legend-item">
            <div class="color-box" style="background-color: #e74c3c;"></div>
            <span>Результат отсечения</span>
          </div>
        </div>

        <div id="status" class="status">
          Готов к работе. Загружен пример данных.
        </div>
      </div>

      <div class="visualization">
        <h3 class="section-title">Визуализация</h3>
        <div class="canvas-container">
          <canvas id="canvas" width="800" height="600"></canvas>
        </div>

        <div class="info-panel">
          <div>Масштаб: 1 единица = 2 пикселя</div>
          <div id="mouseCoords">Координаты: (0, 0)</div>
        </div>
      </div>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const inputData = document.getElementById('inputData');
    const loadExampleBtn = document.getElementById('loadExample');
    const clearCanvasBtn = document.getElementById('clearCanvas');
    const drawOriginalBtn = document.getElementById('drawOriginal');
    const clipBtn = document.getElementById('clipBtn');
    const midpointBtn = document.getElementById('midpointBtn');
    const polygonBtn = document.getElementById('polygonBtn');
    const statusDiv = document.getElementById('status');
    const mouseCoords = document.getElementById('mouseCoords');
    let currentAlgorithm = 'midpoint'; // 'midpoint' или 'polygon'
    let segments = [];
    let clipWindow = {
      xmin: 0,
      ymin: 0,
      xmax: 0,
      ymax: 0
    };
    let originalPolygon = [];
    let isDrawingPolygon = false;
    let scale = 1; 
    const colors = {
      window: '#2c3e50',
      original: '#4a6491',
      clipped: '#e74c3c',
      grid: '#e0e0e0',
      axes: '#333'
    };
    function init() {
      loadExample();
      loadExampleBtn.addEventListener('click', loadExample);
      clearCanvasBtn.addEventListener('click', clearCanvas);
      drawOriginalBtn.addEventListener('click', drawOriginal);
      clipBtn.addEventListener('click', clip);
      midpointBtn.addEventListener('click', () => {
        setActiveAlgorithm('midpoint');
        loadExample();
      });
      polygonBtn.addEventListener('click', () => {
        setActiveAlgorithm('polygon');
        loadPolygonExample();
      });
      canvas.addEventListener('mousemove', handleMouseMove);
      drawCoordinateSystem();
      parseInputData();
      drawAll();
    }
    function setActiveAlgorithm(algorithm) {
      currentAlgorithm = algorithm;
      if (algorithm === 'midpoint') {
        midpointBtn.classList.add('active');
        polygonBtn.classList.remove('active');
        inputData.placeholder = "Введите данные для отрезков...";
        statusDiv.textContent = "Активен алгоритм средней точки для отсечения отрезков.";
      } else {
        midpointBtn.classList.remove('active');
        polygonBtn.classList.add('active');
        inputData.placeholder = "Введите данные для многоугольника...";
        statusDiv.textContent = "Активен алгоритм отсечения выпуклого многоугольника.";
      }
    }
    function loadExample() {
      inputData.value = `7
50 50 250 200
100 20 300 120
30 150 180 80
200 30 350 180
80 180 150 250
120 100 120 250
250 50 50 250
100 100 300 250`;
      parseInputData();
      drawAll();
      statusDiv.textContent = "Загружен пример данных для отрезков. Нажмите 'Выполнить отсечение'.";
    }
    function loadPolygonExample() {
      inputData.value = `6
150 50
250 150
200 300
100 300
50 200
80 100
100 100 300 250`;
      parseInputData();
      drawAll();
      statusDiv.textContent = "Загружен пример данных для многоугольника. Нажмите 'Выполнить отсечение'.";
    }
    function clearCanvas() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawCoordinateSystem();
      segments = [];
      originalPolygon = [];
      clipWindow = {
        xmin: 0,
        ymin: 0,
        xmax: 0,
        ymax: 0
      };
      statusDiv.textContent = "Холст очищен. Введите новые данные или загрузите пример.";
    }
    function parseInputData() {
      const lines = inputData.value.trim().split('\n');
      if (lines.length < 2) {
        statusDiv.textContent = "Ошибка: недостаточно данных.";
        return;
      }
      segments = [];
      originalPolygon = [];
      try {
        if (currentAlgorithm === 'midpoint') {
          const n = parseInt(lines[0]);
          if (isNaN(n) || n <= 0) {
            statusDiv.textContent = "Ошибка: первая строка должна содержать количество отрезков.";
            return;
          }
          for (let i = 1; i <= n && i < lines.length; i++) {
            const coords = lines[i].trim().split(/\s+/).map(Number);
            if (coords.length >= 4) {
              segments.push({
                x1: coords[0],
                y1: coords[1],
                x2: coords[2],
                y2: coords[3]
              });
            }
          }
          const lastLine = lines[lines.length - 1].trim().split(/\s+/).map(Number);
          if (lastLine.length >= 4) {
            clipWindow = {
              xmin: lastLine[0],
              ymin: lastLine[1],
              xmax: lastLine[2],
              ymax: lastLine[3]
            };
          }
          statusDiv.textContent = `Загружено ${segments.length} отрезков. Отсекающее окно: (${clipWindow.xmin}, ${clipWindow.ymin}) - (${clipWindow.xmax}, ${clipWindow.ymax})`;
        } else {
          const n = parseInt(lines[0]);
          if (isNaN(n) || n <= 0) {
            statusDiv.textContent = "Ошибка: первая строка должна содержать количество вершин многоугольника.";
            return;
          }
          for (let i = 1; i <= n && i < lines.length; i++) {
            const coords = lines[i].trim().split(/\s+/).map(Number);
            if (coords.length >= 2) {
              originalPolygon.push({
                x: coords[0],
                y: coords[1]
              });
            }
          }
          const lastLine = lines[lines.length - 1].trim().split(/\s+/).map(Number);
          if (lastLine.length >= 4) {
            clipWindow = {
              xmin: lastLine[0],
              ymin: lastLine[1],
              xmax: lastLine[2],
              ymax: lastLine[3]
            };
          }
          statusDiv.textContent = `Загружен многоугольник с ${originalPolygon.length} вершинами. Отсекающее окно: (${clipWindow.xmin}, ${clipWindow.ymin}) - (${clipWindow.xmax}, ${clipWindow.ymax})`;
        }
      } catch (error) {
        statusDiv.textContent = "Ошибка при разборе входных данных. Проверьте формат.";
        console.error(error);
      }
    }
    function drawCoordinateSystem() {
      const width = canvas.width;
      const height = canvas.height;
      ctx.clearRect(0, 0, width, height);
      ctx.fillStyle = '#fefefe';
      ctx.fillRect(0, 0, width, height);
      ctx.strokeStyle = colors.grid;
      ctx.lineWidth = 0.5;
      for (let x = 0; x <= width; x += 20) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, height);
        ctx.stroke();
      }
      for (let y = 0; y <= height; y += 20) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(width, y);
        ctx.stroke();
      }
      ctx.strokeStyle = colors.axes;
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.moveTo(0, height / 2);
      ctx.lineTo(width, height / 2);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(width / 2, 0);
      ctx.lineTo(width / 2, height);
      ctx.stroke();
      ctx.fillStyle = colors.axes;
      ctx.font = '12px Arial';
      ctx.fillText('X', width - 10, height / 2 - 10);
      ctx.fillText('Y', width / 2 + 10, 10);
      ctx.strokeStyle = colors.axes;
      ctx.lineWidth = 1;
      for (let x = -width / 2 / scale; x <= width / 2 / scale; x += 50) {
        const screenX = width / 2 + x * scale;
        ctx.beginPath();
        ctx.moveTo(screenX, height / 2 - 5);
        ctx.lineTo(screenX, height / 2 + 5);
        ctx.stroke();
        if (x !== 0) {
          ctx.fillText(x.toString(), screenX - 10, height / 2 + 20);
        }
      }
      for (let y = -height / 2 / scale; y <= height / 2 / scale; y += 50) {
        const screenY = height / 2 - y * scale;
        ctx.beginPath();
        ctx.moveTo(width / 2 - 5, screenY);
        ctx.lineTo(width / 2 + 5, screenY);
        ctx.stroke();
        if (y !== 0) {
          ctx.fillText(y.toString(), width / 2 + 10, screenY + 4);
        }
      }
      ctx.fillText('0', width / 2 - 12, height / 2 + 20);
    }
    function worldToScreen(x, y) {
      const width = canvas.width;
      const height = canvas.height;
      return {
        x: width / 2 + x * scale,
        y: height / 2 - y * scale
      };
    }
    function drawSegment(segment, color, lineWidth = 2) {
      const p1 = worldToScreen(segment.x1, segment.y1);
      const p2 = worldToScreen(segment.x2, segment.y2);
      ctx.beginPath();
      ctx.moveTo(p1.x, p1.y);
      ctx.lineTo(p2.x, p2.y);
      ctx.strokeStyle = color;
      ctx.lineWidth = lineWidth;
      ctx.stroke();
    }
    function drawPolygon(polygon, color, fill = false) {
      if (polygon.length < 2) return;
      const screenPoints = polygon.map(p => worldToScreen(p.x, p.y));
      ctx.beginPath();
      ctx.moveTo(screenPoints[0].x, screenPoints[0].y);
      for (let i = 1; i < screenPoints.length; i++) {
        ctx.lineTo(screenPoints[i].x, screenPoints[i].y);
      }
      ctx.lineTo(screenPoints[0].x, screenPoints[0].y);
      ctx.strokeStyle = color;
      ctx.lineWidth = 2;
      ctx.stroke();
      if (fill) {
        ctx.fillStyle = color + '40'; // Полупрозрачная заливка
        ctx.fill();
      }
    }
    function drawClipWindow() {
      const p1 = worldToScreen(clipWindow.xmin, clipWindow.ymin);
      const p2 = worldToScreen(clipWindow.xmax, clipWindow.ymax);
      ctx.beginPath();
      ctx.rect(p1.x, p2.y, p2.x - p1.x, p1.y - p2.y);
      ctx.strokeStyle = colors.window;
      ctx.lineWidth = 2;
      ctx.stroke();
      ctx.fillStyle = colors.window + '20';
      ctx.fill();
    }
    function drawAll() {
      drawCoordinateSystem();
      drawClipWindow();
      if (currentAlgorithm === 'midpoint') {
        segments.forEach(segment => {
          drawSegment(segment, colors.original);
        });
      } else {
        if (originalPolygon.length > 0) {
          drawPolygon(originalPolygon, colors.original, false);
        }
      }
    }
    function drawOriginal() {
      parseInputData();
      drawAll();
      statusDiv.textContent = "Отображены исходные данные.";
    }
    function handleMouseMove(event) {
      const rect = canvas.getBoundingClientRect();
      const x = event.clientX - rect.left;
      const y = event.clientY - rect.top;
      const worldX = (x - canvas.width / 2) / scale;
      const worldY = (canvas.height / 2 - y) / scale;
      mouseCoords.textContent = `Координаты: (${worldX.toFixed(1)}, ${worldY.toFixed(1)})`;
    }
    function clip() {
      parseInputData();
      drawAll();
      if (currentAlgorithm === 'midpoint') {
        clipSegmentsMidpoint();
      } else {
        clipPolygon();
      }
    }
    function clipSegmentsMidpoint() {
      let clippedCount = 0;
      segments.forEach(segment => {
        const result = midpointClip(
          segment.x1, segment.y1,
          segment.x2, segment.y2,
          clipWindow.xmin, clipWindow.ymin,
          clipWindow.xmax, clipWindow.ymax
        );
        if (result) {
          clippedCount++;
          drawSegment(result, colors.clipped, 3);
        }
      });
      statusDiv.textContent = `Отсечение выполнено. Отображено ${clippedCount} видимых отрезков.`;
    }
    function midpointClip(x1, y1, x2, y2, xmin, ymin, xmax, ymax) {
      let code1 = computeCode(x1, y1, xmin, ymin, xmax, ymax);
      let code2 = computeCode(x2, y2, xmin, ymin, xmax, ymax);
      if (code1 === 0 && code2 === 0) {
        return {
          x1,
          y1,
          x2,
          y2
        };
      }
      if ((code1 & code2) !== 0) {
        return null;
      }
      let midX = (x1 + x2) / 2;
      let midY = (y1 + y2) / 2;
      if (Math.abs(x1 - x2) < 0.5 && Math.abs(y1 - y2) < 0.5) {
        if (computeCode(midX, midY, xmin, ymin, xmax, ymax) === 0) {
          return {
            x1: midX,
            y1: midY,
            x2: midX,
            y2: midY
          };
        }
        return null;
      }
      const leftPart = midpointClip(x1, y1, midX, midY, xmin, ymin, xmax, ymax);
      const rightPart = midpointClip(midX, midY, x2, y2, xmin, ymin, xmax, ymax);
      if (!leftPart && !rightPart) {
        return null;
      }
      if (!leftPart) return rightPart;
      if (!rightPart) return leftPart;
      return {
        x1: leftPart.x1,
        y1: leftPart.y1,
        x2: rightPart.x2,
        y2: rightPart.y2
      };
    }
    function computeCode(x, y, xmin, ymin, xmax, ymax) {
      let code = 0;
      if (x < xmin) code |= 1;
      if (x > xmax) code |= 2; 
      if (y < ymin) code |= 4; 
      if (y > ymax) code |= 8; 
      return code;
    }
    function clipPolygon() {
      if (originalPolygon.length < 3) {
        statusDiv.textContent = "Ошибка: многоугольник должен иметь хотя бы 3 вершины.";
        return;
      }
      let outputList = [...originalPolygon];
      outputList = clipAgainstEdge(outputList, 'left', clipWindow.xmin);
      outputList = clipAgainstEdge(outputList, 'right', clipWindow.xmax);
      outputList = clipAgainstEdge(outputList, 'bottom', clipWindow.ymin);
      outputList = clipAgainstEdge(outputList, 'top', clipWindow.ymax);
      if (outputList.length >= 3) {
        drawPolygon(outputList, colors.clipped, true);
        statusDiv.textContent = `Отсечение выполнено. Многоугольник имеет ${outputList.length} вершин после отсечения.`;
      } else {
        statusDiv.textContent = "Многоугольник полностью невидим после отсечения.";
      }
    }
    function clipAgainstEdge(polygon, edge, boundary) {
      const outputList = [];
      const n = polygon.length;
      for (let i = 0; i < n; i++) {
        const current = polygon[i];
        const next = polygon[(i + 1) % n];
        const currentInside = isInside(current, edge, boundary);
        const nextInside = isInside(next, edge, boundary);
        if (currentInside && nextInside) {
          outputList.push(next);
        } else if (currentInside && !nextInside) {
          const intersect = findIntersection(current, next, edge, boundary);
          outputList.push(intersect);
        } else if (!currentInside && nextInside) {
          const intersect = findIntersection(current, next, edge, boundary);
          outputList.push(intersect);
          outputList.push(next);
        }
      }
      return outputList;
    }
    function isInside(point, edge, boundary) {
      switch (edge) {
        case 'left':
          return point.x >= boundary;
        case 'right':
          return point.x <= boundary;
        case 'bottom':
          return point.y >= boundary;
        case 'top':
          return point.y <= boundary;
        default:
          return false;
      }
    }
    function findIntersection(p1, p2, edge, boundary) {
      if (edge === 'left' || edge === 'right') {
        const y = p1.y + (p2.y - p1.y) * (boundary - p1.x) / (p2.x - p1.x);
        return {
          x: boundary,
          y
        };
      }
      else {
        const x = p1.x + (p2.x - p1.x) * (boundary - p1.y) / (p2.y - p1.y);
        return {
          x,
          y: boundary
        };
      }
    }
    window.onload = init;
  </script>
</body>

</html>
