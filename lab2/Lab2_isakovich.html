<!doctype html>
<html lang="ru">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Lab#2 - Чтение информации из графических файлов</title>
  <style>
    :root {
      font-family: Inter, system-ui, Segoe UI, Roboto, Arial, sans-serif;
      color: #111
    }
    
    body {
      margin: 0;
      padding: 20px;
      background: #f7f8fb
    }
    
    .container {
      max-width: 1200px;
      margin: 0 auto
    }
    
    h1 {
      font-size: 20px;
      margin: 0 0 12px
    }
    
    .controls {
      display: flex;
      gap: 8px;
      align-items: center;
      margin-bottom: 12px
    }
    
    .drop {
      flex: 1;
      border: 2px dashed #cbd5e1;
      background: #fff;
      padding: 18px;
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      min-height: 80px;
      cursor: pointer
    }
    
    .btn {
      background: #0ea5a4;
      color: #fff;
      padding: 8px 12px;
      border-radius: 8px;
      border: none;
      cursor: pointer
    }
    
    .btn.secondary {
      background: #64748b
    }
    
    table {
      width: 100%;
      border-collapse: collapse;
      background: #fff;
      border-radius: 8px;
      overflow: hidden
    }
    
    th,
    td {
      padding: 8px;
      border-bottom: 1px solid #e6eef6;
      text-align: left;
      font-size: 13px
    }
    
    th {
      background: #f1f5f9;
      font-weight: 600
    }
    
    .small {
      font-size: 12px;
      color: #475569
    }
    
    .progress {
      height: 10px;
      background: #e6eef6;
      border-radius: 6px;
      overflow: hidden
    }
    
    .progress > i {
      display: block;
      height: 100%;
      width: 0;
      background: #0ea5a4
    }
    
    .topline {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 12px
    }
    
    .help {
      background: #fff;
      padding: 12px;
      border-radius: 8px;
      margin-top: 12px
    }
    
    .actions {
      display: flex;
      gap: 8px
    }
    
    .hidden {
      position: absolute;
      left: -9999px;
      top: -9999px;
      width: 1px;
      height: 1px;
      opacity: 0;
      pointer-events: none
    }
  </style>
</head>

<body>
  <div class="container">
    <div class="topline">
      <h1>Лабораторная работа 2 — чтение информации из графических файлов</h1>
      <div class="actions">
        <button id="clearBtn" class="btn secondary">Очистить</button>
      </div>
    </div>
    <div class="controls">
      <input id="fileInput" type="file" multiple class="hidden">
      <input id="folderInput" type="file" webkitdirectory directory multiple class="hidden">
      <input id="zipInput" type="file" accept=".zip" class="hidden">
      <button id="chooseFolder" class="btn">Выбрать папку</button>
      <button id="chooseFiles" class="btn secondary">Выбрать файлы</button>
      <button id="chooseZip" class="btn">Загрузить ZIP</button>
      <div style="width:320px">
        <div class="progress" aria-hidden="true"><i id="progBar"></i></div>
      </div>
    </div>
    <div id="drop" class="drop">Перетащите файлы или папку сюда или нажмите кнопки выше</div>
    <div style="height:12px"></div>
    <div style="overflow:auto;max-height:54vh">
      <table id="results">
        <thead>
          <tr>
            <th>Имя файла</th>
            <th>Формат</th>
            <th>Размер (px)</th>
            <th>Размер (байт)</th>
            <th>Дата изменения</th>
            <th>Разрешение (dpi)</th>
            <th>Глубина цвета</th>
            <th>Сжатие</th>
            <th class="small">Примечание</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>
    <div class="help">
      <div class="small">Поддерживаемые форматы: jpg, png, gif, tif, bmp, pcx. Можно загружать zip-архивы. Для JPEG рассчитывается коэффициент сжатия (отношение несжатого размера к сжатому).</div>
    </div>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
  <script>
    const drop = document.getElementById('drop')
    const fileInput = document.getElementById('fileInput')
    const folderInput = document.getElementById('folderInput')
    const zipInput = document.getElementById('zipInput')
    const chooseFolder = document.getElementById('chooseFolder')
    const chooseFiles = document.getElementById('chooseFiles')
    const chooseZip = document.getElementById('chooseZip')
    const tbody = document.querySelector('#results tbody')
    const progBar = document.getElementById('progBar')
    const clearBtn = document.getElementById('clearBtn')
    const maxFiles = 100000
    chooseFolder.addEventListener('click', () => folderInput.click())
    chooseFiles.addEventListener('click', () => fileInput.click())
    chooseZip.addEventListener('click', () => zipInput.click())
    drop.addEventListener('dragover', e => {
      e.preventDefault();drop.style.borderColor = '#0ea5a4'
    })
    drop.addEventListener('dragleave', () => drop.style.borderColor = '')
    drop.addEventListener('drop', e => {
      e.preventDefault();drop.style.borderColor = '';handleFiles(e.dataTransfer.files)
    })
    drop.addEventListener('click', () => fileInput.click())
    fileInput.addEventListener('change', e => handleFiles(e.target.files))
    folderInput.addEventListener('change', e => handleFiles(e.target.files))
    zipInput.addEventListener('change', e => handleZip(e.target.files[0]))
    clearBtn.addEventListener('click', () => {
      tbody.innerHTML = '';progBar.style.width = '0%'
    })
    async function handleFiles(list) {
      const files = Array.from(list).filter(f => f.size > 0).slice(0, maxFiles);
      let done = 0;
      progBar.style.width = '0%';
      for (const file of files) {
        try {
          await processFile(file)
        } catch (err) {
          appendRow({
            name: file.name,
            format: '—',
            sizePx: '—',
            bytes: file.size,
            modified: new Date(file.lastModified),
            dpi: '—',
            depth: '—',
            compression: '—',
            note: 'Ошибка: ' + String(err)
          })
        }
        done++;
        progBar.style.width = Math.round(done / files.length * 100) + '%'
      }
      fileInput.value = '';
      folderInput.value = '';
      zipInput.value = ''
    }
    async function handleZip(zipFile) {
      if (!zipFile) return;
      const data = await zipFile.arrayBuffer();
      const z = await JSZip.loadAsync(data);
      const entries = [];
      z.forEach((relativePath, file) => {
        if (!file.dir) entries.push({
          file,
          relativePath
        })
      });
      let done = 0;
      progBar.style.width = '0%';
      for (const e of entries) {
        const content = await e.file.async('uint8array');
        const blob = new Blob([content]);
        const f = new File([blob], e.relativePath, {
          type: '',
          lastModified: (e.file.date ? e.file.date.getTime() : Date.now())
        });
        try {
          await processFile(f)
        } catch (err) {
          appendRow({
            name: e.relativePath,
            format: '—',
            sizePx: '—',
            bytes: blob.size,
            modified: (e.file.date ? e.file.date.toISOString() : '—'),
            dpi: '—',
            depth: '—',
            compression: '—',
            note: 'Ошибка: ' + String(err)
          })
        }
        done++;
        progBar.style.width = Math.round(done / entries.length * 100) + '%'
      }
      zipInput.value = ''
    }
    async function processFile(file) {
      const name = file.name;
      const ext = name.split('.').pop().toLowerCase();
      const head = await readSlice(file, 0, 131072);
      let info = {
        name,
        format: ext,
        sizePx: '—',
        bytes: file.size,
        modified: new Date(file.lastModified),
        dpi: '—',
        depth: '—',
        compression: '—',
        note: ''
      };
      try {
        if (ext === 'jpg' || ext === 'jpeg') {
          const j = parseJpeg(head);
          info.format = 'JPEG';
          if (j.width) info.sizePx = j.width + '×' + j.height;
          if (j.precision) info.depth = j.precision + ' bit ×' + (j.components || '?') + ' ch';
          if (j.dpiX && j.dpiY) {
            info.dpi = Math.round(j.dpiX) + '×' + Math.round(j.dpiY) + ' dpi';
          } else if (j.dpi) {
            info.dpi = Array.isArray(j.dpi) ?
              Math.round(j.dpi[0]) + '×' + Math.round(j.dpi[1]) + ' dpi' :
              String(j.dpi);
          }
          const compressionInfo = calculateJpegCompression(j, file.size);
          info.compression = compressionInfo;
        } else if (ext === 'png') {
          const p = parsePng(head);
          info.format = 'PNG';
          if (p.width) info.sizePx = p.width + '×' + p.height;
          if (p.bitDepth) info.depth = p.bitDepth + ' bit';
          if (p.dpiX && p.dpiY) {
            info.dpi = Math.round(p.dpiX) + '×' + Math.round(p.dpiY) + ' dpi';
          } else if (p.dpi) {
            info.dpi = String(p.dpi) + ' dpi';
          }
          info.compression = 'Deflate (zlib)'
        } else if (ext === 'gif') {
          const g = parseGif(head);
          info.format = 'GIF';
          if (g.width) info.sizePx = g.width + '×' + g.height;
          if (g.colors) info.depth = g.colors + ' colors';
          info.compression = 'LZW'
        } else if (ext === 'bmp') {
          const b = parseBmp(head);
          info.format = 'BMP';
          if (b.width) info.sizePx = b.width + '×' + b.height;
          if (b.depth) info.depth = (b.depth || '') + ' bit';
          info.compression = b.compression || 'None'
          if (b.dpiX && b.dpiY) {
            info.dpi = Math.round(b.dpiX) + '×' + Math.round(b.dpiY) + ' dpi';
          }
        } else if (ext === 'tif' || ext === 'tiff') {
          const t = parseTiff(head);
          info.format = 'TIFF';
          if (t.width) info.sizePx = t.width + '×' + t.height;
          if (t.depth) info.depth = (t.depth ? Array.isArray(t.depth) ? t.depth.join('/') + ' bit' : t.depth + ' bit' : '—');
          if (t.dpiX && t.dpiY) {
            info.dpi = Math.round(t.dpiX) + '×' + Math.round(t.dpiY) + ' dpi';
          } else if (t.dpi) {
            info.dpi = Array.isArray(t.dpi) ?
              Math.round(t.dpi[0]) + '×' + Math.round(t.dpi[1]) + ' dpi' :
              String(t.dpi);
          }
          if (t.compression) info.compression = t.compression
        } else if (ext === 'pcx') {
          const p = parsePcx(head);
          info.format = 'PCX';
          if (p.width) info.sizePx = p.width + '×' + p.height;
          if (p.depth) info.depth = p.depth + ' bit';
          info.compression = p.encoding === '1' ? 'RLE' : 'Unknown'
        } else {
          const img = await decodeImage(file);
          info.sizePx = img.width + '×' + img.height;
          info.format = ext.toUpperCase();
          info.note = 'Metadata not parsed'
        }
      } catch (e) {
        info.note = 'Ошибка парсинга: ' + e.message
      }
      appendRow(info)
    }

    function calculateJpegCompression(jpegInfo, fileSize) {
      if (!jpegInfo.width || !jpegInfo.height || fileSize <= 0) {
        return 'JPEG';
      }
      const precision = jpegInfo.precision || 8;
      const components = jpegInfo.components || 3;
      let bytesPerPixel = 0;
      switch (components) {
        case 1:
          bytesPerPixel = precision / 8;
          break;
        case 3:
          bytesPerPixel = (precision / 8) * 1.5;
          break;
        case 4:
          bytesPerPixel = (precision / 8) * 4;
          break;
        default:
          bytesPerPixel = (precision / 8) * components;
      }
      const uncompressedBytes = Math.round(jpegInfo.width * jpegInfo.height * bytesPerPixel);
      if (uncompressedBytes <= fileSize || uncompressedBytes <= 0) {
        return 'JPEG';
      }
      const compressionRatio = (uncompressedBytes / fileSize).toFixed(1);
      const compressionPercent = Math.round((1 - (fileSize / uncompressedBytes)) * 100);
      const safePercent = Math.max(0, Math.min(99, compressionPercent));
      return `JPEG ${safePercent}% (${compressionRatio}:1)`;
    }

    function appendRow(i) {
      const mod = (i.modified && i.modified instanceof Date) ? i.modified.toLocaleString() : i.modified || '—';
      const tr = document.createElement('tr');
      tr.innerHTML = '<td>' + escapeHtml(i.name) + '</td><td>' + escapeHtml(i.format) + '</td><td>' + escapeHtml(i.sizePx) + '</td><td>' + escapeHtml(i.bytes || '—') + '</td><td>' + escapeHtml(mod) + '</td><td>' + escapeHtml(i.dpi) + '</td><td>' + escapeHtml(i.depth) + '</td><td>' + escapeHtml(i.compression) + '</td><td class="small">' + escapeHtml(i.note) + '</td>';
      tbody.appendChild(tr)
    }

    function escapeHtml(s) {
      return s === null || s === undefined ? '' : String(s).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;')
    }

    function readSlice(file, start, len) {
      return new Promise((res, rej) => {
        const r = new FileReader();r.onload = () => res(new Uint8Array(r.result));r.onerror = () => rej(r.error);r.readAsArrayBuffer(file.slice(start, start + len))
      })
    }

    function u16(data, off, le) {
      return le ? data[off] | (data[off + 1] << 8) : (data[off] << 8) | data[off + 1]
    }

    function u32(data, off, le) {
      if (le) return data[off] | data[off + 1] << 8 | data[off + 2] << 16 | data[off + 3] << 24;
      return data[off] << 24 | data[off + 1] << 16 | data[off + 2] << 8 | data[off + 3]
    }

    function parseJpeg(data) {
      let off = 0;
      const dv = data;
      if (dv[0] !== 0xFF || dv[1] !== 0xD8) return {};
      off = 2;
      let info = {};
      while (off + 4 < dv.length) {
        if (dv[off] !== 0xFF) break;
        let marker = dv[off + 1];
        off += 2;
        if (marker === 0xDA) break;
        const len = (dv[off] << 8) | dv[off + 1];
        if (len < 2) break;
        const payloadStart = off + 2;
        const payloadEnd = payloadStart + len - 2;
        if (marker >= 0xC0 && marker <= 0xC3) {
          info.precision = dv[payloadStart];
          info.height = (dv[payloadStart + 1] << 8) | dv[payloadStart + 2];
          info.width = (dv[payloadStart + 3] << 8) | dv[payloadStart + 4];
          info.components = dv[payloadStart + 5];
        }
        if (marker === 0xE1) {
          const sig = String.fromCharCode.apply(null, Array.from(dv.slice(payloadStart, payloadStart + 4)));
          if (sig === 'Exif') {
            const exifData = dv.slice(payloadStart + 6, payloadEnd);
            const exif = parseExif(exifData);
            if (exif.resolutionX && exif.resolutionY) {
              info.dpiX = exif.resolutionX;
              info.dpiY = exif.resolutionY;
            }
          }
        }
        if (marker === 0xE0) {
          const jfifSig = String.fromCharCode.apply(null, Array.from(dv.slice(payloadStart, payloadStart + 4)));
          if (jfifSig === 'JFIF') {
            const densityUnits = dv[payloadStart + 7];
            const xDensity = (dv[payloadStart + 8] << 8) | dv[payloadStart + 9];
            const yDensity = (dv[payloadStart + 10] << 8) | dv[payloadStart + 11];
            if (densityUnits === 1 && xDensity > 0 && yDensity > 0) {
              info.dpiX = xDensity;
              info.dpiY = yDensity;
            }
          }
        }
        off = payloadEnd
      }
      return info
    }

    function parseExif(buf) {
      if (buf.length < 8) return {};
      const isLittleEndian = (buf[0] === 0x49 && buf[1] === 0x49);
      if (!isLittleEndian && !(buf[0] === 0x4D && buf[1] === 0x4D)) return {};
      const ifd0Offset = u32(buf, 4, isLittleEndian);
      let result = {};
      parseIfd(buf, ifd0Offset, isLittleEndian, result);
      return result;
    }

    function parseIfd(buf, offset, le, result) {
      if (offset + 2 > buf.length) return;
      const numEntries = u16(buf, offset, le);
      offset += 2;
      for (let i = 0; i < numEntries; i++) {
        if (offset + 12 > buf.length) break;
        const tag = u16(buf, offset, le);
        const type = u16(buf, offset + 2, le);
        const count = u32(buf, offset + 4, le);
        const valueOffset = offset + 8;
        if (tag === 0x011A || tag === 0x011B || tag === 0x0128 || tag === 0x0129) {
          let resolution = readExifValue(buf, valueOffset, type, count, le, true);
          if (resolution !== undefined) {
            if (tag === 0x011A) result.resolutionX = resolution;
            if (tag === 0x011B) result.resolutionY = resolution;
          }
        }
        offset += 12;
      }
    }

    function readExifValue(buf, offset, type, count, le, isOffset) {
      if (type === 5 && count === 1) {
        let numOffset = u32(buf, offset, le);
        if (isOffset && numOffset + 8 <= buf.length) {
          const numerator = u32(buf, numOffset, le);
          const denominator = u32(buf, numOffset + 4, le);
          return denominator !== 0 ? numerator / denominator : undefined;
        }
      }
      return undefined;
    }

    function parsePng(data) {
      if (data[0] !== 0x89 || String.fromCharCode(data[1], data[2], data[3]) !== 'PNG') return {};
      let off = 8;
      let info = {};
      while (off + 12 < data.length) {
        const len = u32(data, off, false);
        const type = String.fromCharCode.apply(null, Array.from(data.slice(off + 4, off + 8)));
        const chunkStart = off + 8;
        if (type === 'IHDR') {
          info.width = u32(data, chunkStart, false);
          info.height = u32(data, chunkStart + 4, false);
          info.bitDepth = data[chunkStart + 8];
          info.colorType = data[chunkStart + 9];
        }
        if (type === 'pHYs') {
          const ppux = u32(data, chunkStart, false);
          const ppuy = u32(data, chunkStart + 4, false);
          const unit = data[chunkStart + 8];
          if (unit === 1) {
            info.dpiX = Math.round(ppux / 39.3701);
            info.dpiY = Math.round(ppuy / 39.3701);
          }
        }
        off += 12 + len;
        if (off >= data.length) break;
      }
      return info
    }

    function parseGif(data) {
      if (String.fromCharCode.apply(null, Array.from(data.slice(0, 3))) !== 'GIF') return {};
      const width = u16(data, 6, true);
      const height = u16(data, 8, true);
      const packed = data[10];
      const gct = (packed & 0x80) ? Math.pow(2, (packed & 7) + 1) : 0;
      return {
        width,
        height,
        colors: gct
      }
    }

    function parseBmp(data) {
      if (String.fromCharCode.apply(null, Array.from(data.slice(0, 2))) !== 'BM') return {};
      const headerSize = u32(data, 14, true);
      const width = u32(data, 18, true);
      const height = u32(data, 22, true);
      const planes = u16(data, 26, true);
      const bpp = u16(data, 28, true);
      const compression = u32(data, 30, true);
      let comp = 'BI_RGB';
      if (compression === 1) comp = 'RLE-8';
      if (compression === 2) comp = 'RLE-4';
      if (compression === 3) comp = 'BITFIELDS';
      if (compression === 4) comp = 'JPEG';
      if (compression === 5) comp = 'PNG';
      const ppmX = u32(data, 38, true);
      const ppmY = u32(data, 42, true);
      let dpiX, dpiY;
      if (ppmX > 0) dpiX = Math.round(ppmX / 39.3701);
      if (ppmY > 0) dpiY = Math.round(ppmY / 39.3701);
      return {
        width: Math.abs(width),
        height: Math.abs(height),
        depth: bpp,
        compression: comp,
        dpiX: dpiX,
        dpiY: dpiY
      }
    }

    function parseTiff(data) {
      if (data.length < 8) return {};
      const isLittleEndian = (data[0] === 0x49 && data[1] === 0x49);
      const magic = u16(data, 2, isLittleEndian);
      if (magic !== 0x002A && magic !== 0x2A00) return {};
      const ifdOffset = u32(data, 4, isLittleEndian);
      let info = {};
      if (parseTiffIfd(data, ifdOffset, isLittleEndian, info)) {
        return info;
      }
      return {};
    }

    function parseTiffIfd(data, offset, le, info) {
      if (offset + 2 > data.length) return false;
      const numEntries = u16(data, offset, le);
      offset += 2;
      for (let i = 0; i < numEntries; i++) {
        if (offset + 12 > data.length) break;
        const tag = u16(data, offset, le);
        const type = u16(data, offset + 2, le);
        const count = u32(data, offset + 4, le);
        let value = u32(data, offset + 8, le);
        switch (tag) {
          case 256:
            info.width = value;
            break;
          case 257:
            info.height = value;
            break;
          case 258:
            if (count === 1) info.depth = value;
            else if (count > 1 && value + count * 2 <= data.length) {
              const depths = [];
              for (let j = 0; j < count; j++) {
                depths.push(u16(data, value + j * 2, le));
              }
              info.depth = depths;
            }
            break;
          case 259:
            info.compression = value === 1 ? 'None' : value === 5 ? 'LZW' : 'Unknown';
            break;
          case 282:
          case 283:
            if (value + 8 <= data.length) {
              const num = u32(data, value, le);
              const den = u32(data, value + 4, le);
              const res = den !== 0 ? num / den : 0;
              if (tag === 282) info.dpiX = res;
              else info.dpiY = res;
            }
            break;
        }
        offset += 12;
      }
      return true;
    }

    function parsePcx(data) {
      if (data[0] !== 0x0A) return {};
      const version = data[1];
      const encoding = data[2];
      const bits = data[3];
      const xmin = u16(data, 4, true);
      const ymin = u16(data, 6, true);
      const xmax = u16(data, 8, true);
      const ymax = u16(data, 10, true);
      const width = xmax - xmin + 1;
      const height = ymax - ymin + 1;
      return {
        width,
        height,
        depth: bits,
        encoding: encoding
      }
    }

    function decodeImage(file) {
      return new Promise((res, rej) => {
        const img = new Image();
        const url = URL.createObjectURL(file);
        img.onload = () => {
          URL.revokeObjectURL(url);
          res({
            width: img.naturalWidth,
            height: img.naturalHeight
          })
        };
        img.onerror = () => {
          URL.revokeObjectURL(url);
          rej(new Error('Failed to decode image'))
        };
        img.src = url
      })
    }
  </script>
</body>

</html>
